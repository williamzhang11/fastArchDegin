# 工厂模式

工厂模式是常用的实例化对象模式，用工厂方法代替new操作的一种模式。工厂模式抽象了对象创建的具体细节，隐藏了创建过程的复杂度。

好处：

(1) 解耦 ：把对象的创建和使用的过程分开

(2)降低代码重复: 如果创建某个对象的过程都很复杂，需要一定的代码量，而且很多地方都要用到，那么就会有很多的重复代码。

(3) 降低维护成本 ：由于创建过程都由工厂统一管理，所以发生业务逻辑变化，不需要找到所有需要创建对象B的地方去逐个修正，只需要在工厂里修改即可，降低维护成本。

适用场景:

（1）需要创建的对象较少。

（2）客户端不关心对象的创建过程。

## 简单工程模式
又称静态工厂方法模式

角色分配:

(1)工厂(Factory)角色 :简单工厂模式的核心，它负责实现创建所有实例的内部逻辑。工厂类可以被外界直接调用，创建所需的产品对象.

(2)抽象产品(Product)角色 :简单工厂模式所创建的所有对象的父类，它负责描述所有实例所共有的公共接口。

(3)具体产品(Concrete Product)角色:简单工厂模式的创建目标，所有创建的对象都是充当这个角色的某个具体类的实例。



## 工厂方法模式

又称多态性工厂

工厂方法模式是简单工厂的仅一步深化， 在工厂方法模式中，我们不再提供一个统一的工厂类来创建所有的对象，而是针对不同的对象提供不同的工厂。
也就是说 每个对象都有一个与之对应的工厂 。

角色分配

抽象工厂(Abstract Factory)角色：是工厂方法模式的核心，与应用程序无关。任何在模式中创建的对象的工厂类必须实现这个接口。

具体工厂(Concrete Factory)角色 ：这是实现抽象工厂接口的具体工厂类，包含与应用程序密切相关的逻辑，并且受到应用程序调用以创建某一种产品对象。

抽象产品(AbstractProduct)角色 ：工厂方法模式所创建的对象的超类型，也就是产品对象的共同父类或共同拥有的接口。

具体产品(Concrete Product)角色 ：这个角色实现了抽象产品角色所定义的接口。某具体产品有专门的具体工厂创建，它们之间往往一一对应




## 抽象工厂模式

又称工具箱

其实就是多个实现工厂方法的类合在一起的模式，从上面的例子中，也就是说：

```
public class ConcreteCreator extends Creator {
    Product factoryMethod1() {
        return new ConcreteProduct1();
    }
    Product factoryMethod2(){
        return new ConcreteProduct2();
    }
}
```

```
public abstract class Creator {
    abstract Product factoryMethod1();
    abstract Product factoryMethod2();
}



```











https://segmentfault.com/a/1190000015050674