# 单例模式

这种模式涉及到一个单一的类，该类负责创建自己的对象，同时确保只有单个对象被创建。
这个类提供了一种访问其唯一的对象的方式，可以直接访问，不需要实例化该类的对象。

1、单例类只能有一个实例。
2、单例类必须自己创建自己的唯一实例。
3、单例类必须给所有其他对象提供这一实例。


## 饿汉模式
线程安全，缺点：类加载时初始化，浪费内存

## 懒汉模式

 * 懒汉模式，线程安全
 * 
 * 优点：第一次调用时初始化，避免内存浪费
 * 
 * 缺点：必须加锁synchronized才能保证线程安全，加锁影响效率，大部分情况下是不需要同步的

## 双重检查锁实现

 * 双重校验锁
 * 
 * 执行双重检查是因为，如果多个线程同时了通过了第一次检查，并且其中一个线程首先通过了第二次检查并实例化了对象，那么剩余通过了第一次
 * 检查的线程就不会再去实例化对象。
 * 除了初始化的时候会出现加锁的情况，后续的所有调用都会避免加锁而直接返回，解决了性能消耗的问题
 * 
 
 
 * 使用了volatile关键字后，重排序被禁止，所有的写（write）操作都将发生在读（read）操作之前
 
 实例化对象的那行代码（标记为error的那行），实际上可以分解成以下三个步骤：

(1)分配内存空间

(2)初始化对象

(3)将对象指向刚分配的内存空间

但是有些编译器为了性能的原因，可能会将第二步和第三步进行重排序.

(1)分配内存空间

(2)将对象指向刚分配的内存空间

(3)初始化对象


![image](https://github.com/williamzhang11/fastArchDegin/blob/master/src/main/java/com/xiu/fastarchdegin/image/doublecheck.JPG)

在这种情况下，T7时刻线程B对uniqueSingleton的访问，访问的是一个初始化未完成的对象。

 
 为了解决上述问题，需要在uniqueSingleton前加入关键字volatile。使用了volatile关键字后，重排序被禁止，
所有的写（write）操作都将发生在读（read）操作之前。
 
 https://www.cnblogs.com/xz816111/p/8470048.html
 